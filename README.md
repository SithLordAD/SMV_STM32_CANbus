# SMV_STM32_CANbus
Bruin Racing Supermileage CANbus Library

This library was written for the STM32F446RE. Readaptation is likely required for other boards if you choose to use them in the future. Arduino libraries for the RP2040 Adafruit CAN Feather, Teensy4, and ESP32 are available [here](https://github.com/UCLA-Bruin-Supermileage/UCLA-SMV-CAN/tree/main). The assumption is no boards will continue to use these libraries (except the DAQ board), and thus these libraries are no longer maintained (but are backwards compatible with this one).

## Installation

Before you do anything, you will need to initialize your IOC (the .ioc file) to the correct specification to enable CAN at the right baud rate on your board with the correct interrupt configuration and clock configuration. Contact a DAQ lead if you are having trouble with this.

You will also need to add `HAL_CAN_RxFifo0MsgPendingCallback` and `Error_Handler` into your `main.c` file as defined in our example, `main.c`. If anything is autogenerated already for you, replace it with what we have defined.

Put all `.h` files under /Core/Inc, and put `smv_canbus.c` under /Core/Src. `main.c` in this repo is just an example and does not need to be included for installation.

## Usage

In the functions below, replace anything in all caps with the corresponding enumerator for your board and message type. Enumerators are in `smv_board_enums.h`.

Initialize a new CAN object with:

```
CAN_HandleTypeDef can_handle_t; // generated by IOC
...
CAN can = CAN_new();
can.init(&can, YOUR_BOARD_ID, &can_handle_t); // reference main.c for an example
can.begin(&can); // because this is C, all methods require a pointer to the object itself
```
Send:
```
can.send(&can, YOUR_DATA, TYPE_OF_DATA);
```

A comprehensive class description and list of methods are found under `smv_canbus.h`, inside the struct definition for `CANBUS`. Because this is C, this is technically not a class, but for your use that is not relevant.
