#ifndef __SMVCANBUS_H
#define __SMVCANBUS_H

#include "main.h"


typedef struct {
    uint32_t              TxMailbox;       /* The number of the mail box that transmitted the Tx message */
    CAN_TxHeaderTypeDef   TxHeader;        /* Header containing the information of the transmitted frame */
    uint8_t               TxData[8]; /* Buffer of the data to send */
    CAN_RxHeaderTypeDef   RxHeaderFIFO0;   /* Header containing the information of the received frame */
    uint8_t               RxDataFIFO0[8];  /* Buffer of the received data */

    char hardware[20]; //hardware type from the incoming message
    char dataType[20]; //datatype from the incoming
    int device_id; //id of the device this is operating on

    double data; //data from incoming message
    uint8_t filter_bank; //keep track of which filter bank to fill next; we want to keep it between 0 and 14

    CAN_HandleTypeDef *hcan;
} CANBUS;

/*
Purpose: 
- Initialize can object with our tested can settings 
- Set initial open filter (0x0000) --> gets overwritten if programmer uses AddFilter function
- Initialize filter_bank to 0

Programmer's POV:
- Enable CAN1, initialize CAN pins, enable interrupts, and set clock

Reasons for limiting abstraction (programmer will have to set up ioc in the beginning):
- stm32f4xx_hal_conf has a vital line: #define HAL_CAN_MODULE_ENABLED
    - this file is generated by CubeMX and gets called before the library does; the programmer will be expected to define this macro, which is not that intuitive
- stm32f4xx_hal_msp sets up the pins
    - if the library does this without the programmer interacting with the ioc, the ioc UI will never show the CAN pins, which could be akward
*/
void CAN_QuickSetup(CANBUS *can, int hardware, CAN_HandleTypeDef *can_obj); //implemented

/*
Purpose: 
- Separate starting and initializing CAN. This way, the programmer can set up filters after initializing.
- Initialize TxHeader (except StdId) --> this will probably be moved to QuickSetup at some point

The following HAL functions will be used:
- HAL_CAN_Start(&hcan)
- HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING | CAN_IT_RX_FIFO1_MSG_PENDING) \
*/
void CAN_Run(CANBUS *hcan);

/*
Purpose: return the data double assigned in the CAN interrupt
*/
double CAN_GetData(CANBUS *can);

/*
Purpose: return the dataType string assigned in the CAN interrupt
*/
char* CAN_GetDataType(CANBUS *can);

/*
Purpose: return the hardware string assigned in the CAN interrupt
*/
char* CAN_GetHardware(CANBUS *can);

/*
Purpose:
- Receive only the device+datatype that it needs to reduce the frequency of FIFO interrupts

Method:
- Set filter to encoded ID: [device_id: 4 bits] 000 [data_type: 4 bits]
- Set mask to 0b 1111 1111 1111
- Increment filter_bank every call (must be between 0 and 13 to operate)

*/
void CAN_AddFilterDeviceData(CANBUS *can, int device_id, int data_type);

/*
Purpose:
- Receive only data from a certain device

Method:
- Set filter to 0b [device_id: 4 bits] 000 0000
- Set mask to 0b 1111 111 0000 --> compare only the first 7 bits
- Increment filter_bank every call (must be between 0 and 13 to operate)

*/
void CAN_AddFilterDevice(CANBUS *can, int device_id);

/*
Purpose:
- Cast double message to byte array of 8 bytes (use DoubleCaster union)
- Form TxHeader.StdId from the device_id and data_type
- Check mailbox availability and send message
*/
void CAN_Send(CANBUS *can, double message, uint8_t data_type);

/*
- CubeMX defines a CAN interrupt handler when the programmer enables the interrupt in NVIC settings in ioc
- Any definition of the Fifo0PendingCallback function will override the default definition, if any
- The programmer will define the Fifo0PendingCallback function with GetRxMessage and then call this helper function inside

Purpose:
- Assign the new message to our RxData array
- Use DoubleCaster union to assign the byte array value to the data variable
- Assign the incoming header to our RxHeader object
- Extract the integer values of device_id and data_type encoded in the RxHeader.StdId
    - Look up which strings they are both associated with and assign the appropriate values to hardware[] and dataType[]

*/
void CAN_Interrupt_Helper(CANBUS *can);

#endif