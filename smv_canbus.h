#ifndef __SMVCANBUS_H
#define __SMVCANBUS_H

#include "main.h"

struct CANBUS{
    uint32_t              TxMailbox;       /* The number of the mail box that transmitted the Tx message */
    CAN_TxHeaderTypeDef   TxHeader;        /* Header containing the information of the transmitted frame */
    uint8_t               TxData[8]; /* Buffer of the data to send */
    CAN_RxHeaderTypeDef   RxHeaderFIFO0;   /* Header containing the information of the received frame */
    uint8_t               RxDataFIFO0[8];  /* Buffer of the received data */

    char hardware[20]; //hardware type from the incoming message
    char dataType[20]; //datatype from the incoming
    int device_id; //id of the device this is operating on

    double data; //data from incoming message 

    CAN_HandleTypeDef hcan;

};

void CAN_QuickStart(CANBUS *can, int hardware); 
/*
Purpose: 
- Initialize hcan object with our tested can settings 
- Set initial open filter (0x0000)

Programmer's POV:
- Enable CAN1, initialize CAN pins, enable interrupts, and set clock
- Delete CAN1_Init () and replace function call with CAN_QuickStart(&can1, HS4) for example

Reasons for limiting abstraction (programmer will have to set up ioc in the beginning):
- stm32f4xx_hal_conf has a vital line: #define HAL_CAN_MODULE_ENABLED
    - this file is generated by CubeMX and gets called before the library does; the programmer will be expected to define this macro, which is not that intuitive
- stm32f4xx_hal_msp sets up the pins
    - if the library does this without the programmer interacting with the ioc, the ioc UI will never show the CAN pins, which could be akward

The following HAL functions will be used:
- __HAL_RCC_CAN1_CLK_ENABLE();
- HAL_CAN_Init(&hcan)
- HAL_CAN_ConfigFilter(&hcan, &sFilterConfig)
- HAL_CAN_Start(&hcan)
- HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING | CAN_IT_RX_FIFO1_MSG_PENDING) \
*/


double CAN_GetData(CANBUS *can) {return data}
/*
Purpose: return the data double assigned in the CAN interrupt
*/
char* CAN_GetDataType(CANBUS *can) {return dataType}
/*
Purpose: return the dataType string assigned in the CAN interrupt
*/
char* CAN_GetHardware(CANBUS *can) {return hardware}
/*
Purpose: return the hardware string assigned in the CAN interrupt
*/

void CAN_AddFilter(CANBUS *can, int device_id, int data_type);
/*
Purpose:
- Allow can object to receive only the data that it needs to reduce the frequency of FIFO handling
*/

void CAN_Send(CANBUS *can, double message, uint8_t data_type);
/*
Purpose:
- Cast double message to byte array of 8 bytes (use DoubleCaster union)
- Form TxHeader from the device_id and data_type
- Check mailbox availability and send message

Will use the following HAL functions:
- HAL_CAN_GetTxMailboxesFreeLevel(&hcan)
- HAL_CAN_AddTxMessage(&hcan, &TxHeader, TxData, &TxMailbox)
*/

void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *CanHandle);
/*
- CubeMX defines a can interrupt handler when the programmer enables the interrupt in NVIC settings in ioc
- Any definition of the Fifo0PendingCallback function will override the default definition, if any

Purpose:
- Assign the new message to our RxData array
- Use DoubleCaster union to assign the byte array value to the data variable
- Assign the incoming header to our RxHeader object
- Extract the integer values of device_id and data_type encoded in the RxHeader.StdId
    - Look up which strings they are both associated with and assign the appropriate values to hardware[] and dataType[]

We will use the following HAL functions:
- HAL_CAN_GetRxMessage(CanHandle, CAN_RX_FIFO0, &RxHeaderFIFO0, RxDataFIFO0
*/


/* DoubleCaster Union:
    Unions do not allocate separate memory for each member, so the 64 bit double and the 64 bit array overlap exactly

union DoubleCaster{
    double num;
    uint8_t arr [8];
}
 --> will be included in the utils file  
*/
#endif